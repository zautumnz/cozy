let string.substr = fn (start, length = -1) {
    'string.substr returns the given substring from our input.
    The length of the string to return is optional,
    and will default to the length available.'

    # if there is no length then default to the rest of the string.
    if (length == -1) {
        length = util.len(self) - start
    }

    # start must be positive
    if (start < 0) {
        start = 0
    }

    # if the length of the string is too big then we'll cap it too.
    if (start + length > util.len(self)) {
        length = util.len(self) - start
    }

    # catch bounding-errors.
    if (start >= util.len(self)) {
        return ""
    }

    mutable res = ""
    mutable copied = 0

    for ((start < util.len(self)) && (copied < length)) {
        res += self[start]
        start++
        copied++
    }

    return res
}

util.assert("Hello world".substr(1, 4) == "ello" , "string.substr() failed")
util.assert("Hello world".substr(6) == "world" , "string.substr() failed")
util.assert("天研".substr(0) == "天研" , "string.substr() failed")
util.assert("研天".substr(1) == "天" , "string.substr() failed")
util.assert("天研".substr(2) == "" , "string.substr() failed")
util.assert("天研".substr(0, 2) == "天研" , "string.substr() failed")
util.assert("天研".substr(1, 2) == "研" , "string.substr() failed")
util.assert("天研".substr(1, 100) == "研" , "string.substr() failed")
util.assert("天研".substr(-1, 100) == "天研" , "string.substr() failed")

let string.ltrim = fn () {
    'string.ltrim removes leading whitespace from the string.'
    let reg = "^(\\s+)(.*)$"
    let out = core.match(reg, self)

    if (util.len(out) > 1) {
        return out[2]
    } else {
        return self
    }
}

util.assert(("  天研  ".ltrim() == "天研  "), "string.ltrim failed")
util.assert(("  autumn  ".ltrim() == "autumn  "), "string.ltrim failed")

let string.rtrim = fn () {
    'string.rtrim removes trailing whitespace from the string.'
    let reg = "^(.*?)(\\s*)$"
    let out = core.match(reg, self)

    if (util.len(out) > 0) {
        return out[1]
    } else {
        return self
    }
}
util.assert(("  天研  ".rtrim() == "  天研"), "string.rtrim failed")

let string.find = fn (needle) {
    'string.find returns the offset of the given substring,
    or -1 if it is not found.'

    # get details about ourself
    mutable i = 0
    let l = util.len(self)

    # the length of our search string.
    let L = util.len(needle)

    # get a substring at each possible position
    for (i < l) {
        let possible = self.substr(i, L)
        # does this match?
        if (possible == needle) {
            return i
        }

        i++
    }

    return -1
}

util.assert("autumn".find("a") == 0)
util.assert("autumn".find("t") == 2)
util.assert("autumn".find("z") == -1)
util.assert("天研".find("天研") == 0)
util.assert("st天eve研es".find("研") == 6)

let string.split = fn (sep = " \r\t\n") {
    'string.split returns an array splitting on any characters included
    in the separator string.
    By default the split is on whitespace: " ", "TAB", & "RETURN".'

    mutable i = 0
    let l = util.len(self)
    mutable r = []

    mutable tmp = ""

    for (i < l) {
        # get the character.
        let c = self[i]

        # is the character one of our split-characters?
        if (sep.find(c) != -1) {
            # append any previously-accumulated token into our array.
            if (util.len(tmp) > 0) {
                r = r.append(tmp)
            }
            tmp = ""

        } else {
            # store the character into our accumulator.
            tmp += c
        }

        i++
    }

    # Do we have a dangling-string? If so append it.
    if (util.len(tmp) > 0) {
        r = r.append(tmp)
    }

    return r
}

util.assert(util.len("1 2 3".split()) == 3)
util.assert(util.type("1 2 3".split("2")) == "array")

let string.replace = fn (old, new) {
    'string.replace removes a value from a string,
    replacing it with a new value.'
    mutable s = self
    mutable index = s.find(old)

    for (index >= 0) {
        # get the prefix
        let pre = s.substr(0, index)

        # get the suffix
        let suf = s.substr(index + util.len(old))

        s = pre + new + suf

        index = s.find(old)
    }

    return s
}

util.assert("autumn".replace("a", "A") == "Autumn", "string.replace() failed")
util.assert("autumn".replace("A", "Q") == "autumn", "string.replace() failed")

let string.trim = fn () {
    'string.trim trims whitespace from both ends of the string.'
    return self.ltrim().rtrim()
}

util.assert("  ".trim() == "", "string.trim failed")
util.assert(" 1 ".trim() == "1", "string.trim failed")

let string.tolower = fn () {
    'string.tolower converts the string to lower-case.'
    mutable r = ""

    foreach char in self {
        if (char >= "A" && char <= "Z") {
            char = char.ord()
            char += 32
            char = char.chr()
        }

        r += char
    }

    return r
}

util.assert("Autumn".tolower() == "autumn", "string.tolower() failed")
util.assert("天研".tolower() == "天研", "string.tolower() failed")

let string.toupper = fn () {
    'string.toupper converts the string to upper-case.'
    mutable r = ""

    foreach char in self {
        if (char >= "a" && char <= "z") {
            char = char.ord()
            char -= 32
            char = char.chr()
        }

        r += char
    }

    return r
}

util.assert("autumn".toupper() == "AUTUMN", "string.toupper() failed")
util.assert("天研".toupper() == "天研", "string.toupper() failed")

let string.count = fn (char) {
    'string.count returns the count of a character in a string.'
    mutable c = 0

    foreach chr in self {
        if (chr == char) {
            c += 1
        }
    }

    return c
}

util.assert("autumn".count("a") == 1)
util.assert("autumn".count("E") == 0)
util.assert("研天".count("天") == 1)
util.assert("研研研研研研天".count("研") == 6)

let string.repeat = fn (count) {
    'string.repeat repeats a string n times.'
    mutable r = ""

    if (count < 1) {
        return self
    }

    for (count > 0) {
        r += self
        count--
    }

    return r
}

util.assert(("天研".repeat(3) == "天研天研天研"), "string.repeat failed")
util.assert(("*".repeat(1) == "*"), "string.repeat failed")
util.assert(("*".repeat(0) == "*"), "string.repeat failed")
util.assert(("*".repeat(-1) == "*"), "string.repeat failed")

let string.reverse = fn () {
    'string.reverse reverses a string.'
    mutable r = ""
    mutable l = util.len(self)

    for (l > 0) {
        r += self[l-1]
        l--
    }

    return r
}

util.assert(("天研".reverse() == "研天"), "string.reverse failed")
util.assert(("322".reverse() == "223"), "string.reverse failed")

let string.includes? = fn (s) {
    'string.includes? returns true if the string includes the value.'
    return self.find(s) != -1
}

util.assert("123".includes?("1"))
util.assert(!"123".includes?("4"))
